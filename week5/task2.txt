a. Briefly explain how the C implementation resizes the array when it becomes full.
In the C implementation, we check the capacity of the list when adding a new element. If the size of the list 
is the same as the capacity, the program multiple the capacity by 2 creating a larger list.

c. Is manual memory deallocation needed in Java when the array grows? Explain briefly.
No, Java has garbage collection. When we create a new array with size*2 and copy our new values
to that array we do not need to deallocation the previous array. This is handle by garbage collection. 

d. If the list shrinks significantly, what should be done to avoid wasting memory?
We should shrinks the size of the array by size/n

e. When shrinking, why should the array capacity be reduced well below the growth threshold?
What performance issue does this avoid?
The array capacity should be reduced well below the growth threshold to avoid thrashing. 
For example, if growth occurs at size == capacity, shrinking should only occur at size < capacity/4.
When you do shrink, reduce to around size * 2 rather than exactly to size.
This ensures there's a sufficient gap between the shrink threshold and growth threshold.
Otherwise, removing a few elements could trigger a shrink, then adding a few elements could trigger
a grow, creating an expensive cycle of constant resizing. This thrashing wastes CPU cycles and
degrades performance with no benefit to the user. 



