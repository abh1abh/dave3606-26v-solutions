Consider the following C program:

int sum(int* data, int length) {
    int s = 0;
    for (int i = 0; i <= length; i++) {
        s += data[i];
    }
   return s;
}

a. Identify the illegal memory access in the program.
The loop condition i <= length causes the loop to iterate from 0 to length, 
accessing data[0] through data[length]. However, if the array data has length elements, 
valid indices are only 0 to length-1. When i equals length, accessing data[length] is out 
of bounds, which is an illegal memory access. This can be fixed by changing the condition 
to i < length or i <= length - 1

b. Explain why this access leads to undefined behavior in C.
Because accessing an memory address outside an defined array is not allowed. We do not know is saved there, 
and that cause undefined behavior.


d. Could the same bug occur in Java? Explain why or why not
No, the same bug cannot occur in Java in the same way. While you could write the same code 
with i <= length, Java performs runtime bounds checking on array accesses. When the loop 
tries to access data[length], Java throws an ArrayIndexOutOfBoundsException instead of allowing 
illegal memory access. This prevents undefined behavior and makes the error immediately visible to 
the developer.
